\chapter{Introduction}

% TODO:
\chapter{Universal Serial Bus}
\label{usb}
Universal Serial Bus (also known as USB) is a peripheral interface used to connect external devices to computers. It defines the specifications of cables, sets of protocols, the speed of data exchange, and the way the host and device communicate with each other. Not only that, but it can also send power to devices (for example to charge smartphones). 

Before the invention of the USB peripheral, there exists countless kinds of ports in any shape and size. In the past, every peripheral has its shaped connector, a protocol through which it communicated with the computer, and a limited number of devices it can run at once. And that brings many disadvantages. 

First of all computer manufacturers had to decide which sets of ports to include in the final motherboard. We can usually find ports like PS/2 for connecting keyboards and mouses, or VGA connectors for connecting monitors on the old machines. But what if the user wanted to connect a device (for example a scanner or a printer), whose port simply wasn't included with the machine? They usually had to go out and purchase dedicated cards and then manually install them. That is something a person without computer experience might have struggled with. And as for developers during the development of new computer accessories, they had to decide whether to use one of the existing interfaces but run into a risk of being stuck with its original protocols that don't provide enough features the developer needs or design a new interface which is very expensive.

That led to the development of a new interface. In 1995 a group named \textbf{USB Implementers Forum} (also known as USB-IF) was formed by these seven companies: Compaq, DEC, IBM, Intel, Microsoft, NEC, and Nortel. They aimed to create an interface with these goals in their mind:
\begin{itemize}
    \item \textbf{Easy to use} \--- The user doesn't need to configure and set up a device. 
    \item \textbf{Fast} \--- To minimize the delay in communication between the host and device and to be able to transfer 
    \item \textbf{Reliable} \--- To minimize the occurrence of errors and automatic error handling.
    \item \textbf{Versatile} \--- Many kinds of peripherals can use the interface.
    \item \textbf{Inexpensive} \--- So that the price of a final product can be as low as possible. 
    \item \textbf{Supported by all operating systems} \--- It helps developers to write the drivers for the peripherals.
\end{itemize}

A year later, USB-IF released the first version of the USB interface called \textbf{USB 1.0}. The new interface allowed a user to connect a variety of peripherals, such as printers, keyboards, mobile devices, and much more, using a single, standardized interface socket. It also lets the user connect and disconnect a peripheral whenever needed without needing to shut down a computer. And at last, a feature called "plug-and-play" was introduced. It shows the simplicity of the USB \--- the user simply plugs the device into the computer and can immediately use it. 

But it wasn't until the introduction of \textbf{USB 1.1} in 1998 that the interface started to be widely used. In that year the operating system Windows 98 was shipped together with support for USB. Version 1.1 also introduced two speeds: Low Speed with 1.5 Mbps and Full Speed with 12 Mbps.

Over the next 20 years, USB has been constantly upgraded. In April 2000 \textbf{USB 2.0} was released and with it a new maximum transfer rate of 480 Mbps. It was called High Speed. Eight years later in November 2008, USB-IF released a new specification for \textbf{USB 3.0} with an even faster transfer speed of 5 Gbps (named SuperSpeed USB). As for the time of writing this thesis USB-IF has released the specification for \textbf{USB4 2.0} with a maximum transfer rate of 80 Gbps and power delivery of 240 W (48 V, 5 A).

Nowadays almost every device is equipped with some form of USB either for charging or data transfer. From smartphones and game consoles to microcontrollers and soldering iron. And there are currently 14 different types of USB connectors (some of them are shown in \autoref{fig:usb_connectors}, Type-C being the latest one introduced in December 2013.

\begin{figure}[ht]
    \centering
    \includegraphics{obrazky-figures/USB_2.0_and_3.0_connectors.png}
    \caption{List of mostly used USB connectors per generation}
    \label{fig:usb_connectors}
\end{figure}

\subsection*{Communication between Host and Device}
\label{communication}
The standard USB interface has four signal lines and two of those are used to carry data from all of the devices. As seen in \autoref{fig:usb_pins}, the lines are \textbf{Vcc} for the power, \textbf{GND} as ground, and \textbf{D+} and \textbf{D-} for data transfer. Unlike UART, where it uses Rx data line for receiving data and Tx for transferring data, USB uses both wires to carry a single differential signal. Directions are taking turns.

\begin{figure}[ht]
    \centering
    \includegraphics{obrazky-figures/usb_pinouts.png}
    \caption{USB pin layouts}
    \label{fig:usb_pins}
\end{figure}

Before a transfer between the host and devices starts they have to establish some sort of communication canal. In USB terminology that means to establish a \textbf{pipe}. The pipe connects the host with the device's endpoint. \textbf{Endpoint} is an allocated block of memory or a register on the controller's chip where received data or data waiting to be sent are stored. The host doesn't have an endpoint since it initiates and finishes the transmission. The connection is initiated during the \textbf{enumeration} -- an initial sequence of data exchange between the host and device. 

\begin{figure}[ht]
    \centering
    \includegraphics[width=260px]{obrazky-figures/enumeration.png}
    \caption{USB enumeration in sequence diagram}
    \label{fig:enumeration}
\end{figure}

Endpoints are only one-directional, except for control endpoints. The receiver is called \textbf{the sink} and the sender is \textbf{the source}. During the enumeration, the host assigns a unique address for each endpoint defined in the descriptor (more about descriptors in \autoref{descriptor}). The direction is specified in the transaction type which is defined from the host's perspective: \emph{IN} for receiving data (host receives data) and \emph{OUT} for sending data (host sends data). Control (Setup) data must support bidirectional transfer data.

Every device has Endpoint 0 configured for control transfer. It is used by the host to send a request to the device.

\newpage
\begin{table}[ht]
    \centering
    \begin{tabular}{|l|c|c|p{0.39\linewidth}|} \hline
         \textbf{Packet type} & \textbf{PID name} & \textbf{PID value} & \textbf{Description} \\ \hline
         \multirow{4}{3cm}{Token (identifies transaction type} & OUT & 0001 & Device and endpoint address for OUT transaction. \\ \cline {2-4}
           & IN & 1001 & Device and endpoint address for IN transaction. \\ \cline{2-4}
           & SOF & 0101 & Start-of-Frame marker and frame number. \\ \cline{2-4}
           & SETUP & 1101 & Device and endpoint address for Setup transaction. \\ \hline
         \multirow{4}{3cm}{Data (carries data or status code)} & DATA0 & 0011 & Data toggle, data PID sequencing \\ \cline{2-4}
           & DATA1 & 1011 & Data toggle, data PID sequencing \\ \cline{2-4}
           & DATA2 & 0111 & Data PID sequencing \\ \cline{2-4}
           & MDATA & 1111 & Data PID sequencing \\ \hline
         \multirow{4}{3cm}{Handshake (carries status code} & ACK & 0010 & Receiver accepts error-free data packet. \\ \cline{2-4}
           & NAK & 1010 & Receiver can't accept data or sender can't send data or has no data to transmit \\ \cline{2-4}
           & STALL & 1110 & A control request isn't supported or the endpoint is halted. \\ \cline{2-4}
           & NYET & 0110 & Device accepts error-free data packet but isn't yet ready for another or a hub doesn't yet have complete-split data. \\ \hline
        \multirow{5}{3cm}{Special} & PRE & 1100 & Preamble issued by the host to indicate that the next packet is low speed. \\ \cline{2-4}
          & ERR & 1100 & Returned by a hub to report a low- or full-speed error in a split transaction. \\ \cline{2-4}
          & SPLIT & 1000 & Precedes a token packet to indicate a split transaction. \\ \cline{2-4}
          & PING & 0100 & Busy check for bulk OUT and control Write data transaction after NYET. \\ \cline{2-4}
          & reserved & 0000 & For future use. \\ \hline
    \end{tabular}
    \caption{List of Packet ID and their description}
    \label{tab:pid}
\end{table}

There are four types of transfers: Control, Bulk, Interrupt, and Isochronous. Each device can use different types depending on the need. \textbf{Control transfers} enable the host to read information about the device and allow it to configure and update the device's inner status. All USB devices are required to support this type of transfer. \textbf{Bulk transfers} are used in situations where the transfer rate is not critical such as sending a file to the printer or receiving data from the scanner. The priority of the transfer is the lowest. \textbf{Interrupt transfers} on the other hand are implemented in devices where instance feedback is needed. For example, click of a button on the keyboard or a movement of a mouse. \textbf{Isochronous transfers} guarantee delivery of data but no error correction is implemented. Usually used to transfer audio and video in real time. If an error occurs the device doesn't re-transmit lost or corrupted data.

The process of sending data is called \textbf{transfer}. Transfer consists of one or more \textbf{transactions} which are block of packets that starts with \textbf{token packet}. Transaction can also contain additional packets called \textbf{data packet} and \textbf{handshake packet}. Each packet begins with a Packet ID (PID) that specifies what information the packet carries. The list is showed in \autoref{tab:pid}. In the first phase (token phase\footnote{Phase is a part of a sequence of a transaction. There can be three parts named after packets: token phase, data phase and handshake phase}), the host initiates communication by sending a token packet. In data phase, the host or device may transfer any kind of data in the data packet. And in the last (handshake) phase, the host or device sends status information in a handshake packet. There are also four special PIDs only used by low-speed devices. 
    
\subsection*{Descriptors}
\label{descriptor}
USB descriptors are data structures formatted into blocks that contain information about the device. It is used during the enumeration. All USB devices must be able to respond to requests for standard USB descriptors.

There are in total 11 descriptor classes that the device can define but not all of them are required. The list of them is shown in \autoref{tab:descriptor_types}. All descriptor types are identified by their identifier value that is set in \emph{bDescriptorType} field. Each descriptor class consists of a series of fields. There is a standardized naming convention for each field indicating which format of data it contains: \emph{b} is a byte (8 bits), \emph{w} is a word (16 bits), \emph{bm} is a bit map, \emph{bcd} is a binary-coded decimal, \emph{i} is an index, \emph{id} is an identifier. From \autoref{tab:descriptor_types} we can see that three descriptors are required: device, configuration, and interface.

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|l|p{0.39\linewidth}|} \hline
         \textbf{bDescriptorType} & \textbf{Descriptor Type} & \textbf{Required?} \\ \hline
         0x01 & device                      & Yes \\ \hline
         0x02 & configuration               & Yes \\ \hline
         0x03 & string                      & No  \\ \hline
         0x04 & interface                   & Yes \\ \hline
         0x05 & endpoint                    & No if device uses only Endpoint 0 \\ \hline
         0x06 & device\_qualifier           & Only if the device supports both full and high speeds \\ \hline
         0x07 & other\_speed\_configuration & Only if the device supports both full and high speeds \\ \hline
         0x08 & interface\_power            & No \\ \hline
         0x09 & OTG                         & Only for On-The-Go devices \\ \hline
         0x0A & debug                       & No \\ \hline
         0x0B & interface\_association      & Only for composite devices \\ \hline
         \end{tabular}
    \caption{List of descriptor types}
    \label{tab:descriptor_types}
\end{table}

First two bytes of all descriptors stores two important pieces of information: \emph{bLength} declares the size of the descriptor/buffer that the host received and \emph{bDescriptorType} tells the host what type of information can it expect in the buffer.

\textbf{Device} descriptor contains basic information about the device itself such as the version of USB used, device class, manufacture information, number of configurations of the device, and more. It's the first descriptor that is sent to the host. In total, the host will receive a buffer of 18 bytes. After the host retrieves the first descriptor it sends a request for a \textbf{configuration}, \textbf{interface}, and \textbf{endpoint} descriptors. They specify the device's features and abilities. 

When developing a device with a version of USB 2.0 or higher some additional data needs to be set. Since this version of USB allowed a developer to choose what transfer speed to use, he also is responsible to define the device information and configuration of the speed not in use. And for that reason, \textbf{device\_qualifier} and \textbf{other\_speed\_configuration} were created. The former contains \emph{device} descriptor of a device whose speed is currently not in use and the same goes for the latter one with \emph{configuration} descriptor. 

\textbf{Interface association} descriptor identifies multiple interfaces that are associated with a function\footnote{Function as a USB term is a device that provides a capability for the host (for example a keyboard)}. What that means is that a driver can support multiple interfaces within one device, such as the video and audio interface for a webcam. 

\textbf{String} descriptor contains descriptive texts. Other descriptors can address each text using indices. For example, if \emph{iManufacture} is set to \verb|0x03| it tells the host that the name of the manufacturer is stored as the fourth string descriptor. 

Other descriptors \--- \textbf{interface\_power}, \textbf{OTG}, \textbf{debug} \--- are not relevant to this thesis and their definitions can be found in the official documentation.

\autoref{tab:list_descriptors} displays the structure of each descriptor. The tables were taken from Chapter 4 of the book called \emph{USB Complete: Everything You Need to Develop Custom USB Peripherals}. \autoref{lst:dsc_example} shows an example of a device descriptor's buffer.

\begin{longtable}{|c|l|c|} \hline
    \textbf{Descriptor Type} & \textbf{Field} & \textbf{Bytes} \\ \hline
    \multirow{14}{*}{device (0x01)} & bLength & 1 \\ \cline{2-3}
      & bDescriptorType & 1 \\ \cline{2-3} 
      & bcdUSB          & 2 \\ \cline{2-3}
      & bDeviceClass    & 1 \\ \cline{2-3}
      & bDeviceSubclass & 1 \\ \cline{2-3}
      & bDeviceProtocol & 1 \\ \cline{2-3}
      & bMaxPacketSize0 & 1 \\ \cline{2-3}
      & idVendor        & 2 \\ \cline{2-3}
      & idProduct       & 2 \\ \cline{2-3}
      & bcdDevice       & 2 \\ \cline{2-3}
      & iManufacturer   & 1 \\ \cline{2-3}
      & iProduct        & 1 \\ \cline{2-3}
      & iSerialNumber   & 1 \\ \cline{2-3}
      & bNumConfiguration & 1 \\ \hline
    \multirow{8}{*}{configuration(0x02)} & bLength & 1 \\ \cline{2-3}
      & bDescriptorType & 1 \\ \cline{2-3} 
      & wTotalLength    & 2 \\ \cline{2-3}
      & bNumInterfaces  & 1 \\ \cline{2-3}
      & bConfigurationValue & 1 \\ \cline{2-3}
      & iConfiguration  & 1 \\ \cline{2-3}
      & bmAttributes    & 1 \\ \hline
    \pagebreak \hline
    \textbf{Descriptor Type} & \textbf{Field} & \textbf{Bytes} \\ \hline
      configuration(0x02) & bMaxPower       & 1 \\ \hline
    \multirow{3}{*}{string(0x03)} & bLength & 1 \\ \cline{2-3}
      & bDescriptorType & 1 \\ \cline{2-3}
      & bSTRING/wLANGID & 1/2 \\ \hline
    \multirow{9}{*}{interface(0x04)} & bLength & 1 \\ \cline{2-3}
      & bDescriptorType & 1 \\ \cline{2-3}
      & bInterfaceNumber & 1 \\ \cline{2-3}
      & bAlternateSetting & 1 \\ \cline{2-3}
      & bNumEndpoints   & 1 \\ \cline{2-3}
      & bInteraceClass  & 1 \\ \cline{2-3}
      & bInteraceSubclass  & 1 \\ \cline{2-3}
      & bInteraceProtocol  & 1 \\ \cline{2-3}
      & iInterface  & 1 \\ \hline
    \multirow{6}{*}{endpoint(0x05)} & bLength & 1 \\ \cline{2-3}
      & bDescriptorType & 1 \\ \cline{2-3}
      & bEndpointAddress & 1 \\ \cline{2-3}
      & bmAttributes & 1 \\ \cline{2-3}
      & wMaxPacketSize   & 1 \\ \cline{2-3}
      & bInterval  & 1 \\ \hline
    \multirow{9}{*}{device\_qualifier(0x06)} & bLength & 1 \\ \cline{2-3}
      & bDescriptorType & 1 \\ \cline{2-3}
      & bcdUSB          & 2 \\ \cline{2-3}
      & bDeviceClass    & 1 \\ \cline{2-3}
      & bDeviceSubclass & 1 \\ \cline{2-3}
      & bDeviceProtocol & 1 \\ \cline{2-3}
      & bMaxPacketSize0 & 1 \\ \cline{2-3}
      & bNumConfiguration & 1 \\ \cline{2-3}
      & Reserved  & 1 \\ \hline
    other\_speed\_configuration(0x07) & same as \textbf{configuration} & 9 \\ \hline
    \multirow{8}{*}{interface\_association} & bLength & 1 \\ \cline{2-3}
      & bDescriptorType & 1 \\ \cline{2-3}
      & bFirstInterface & 1 \\ \cline{2-3}
      & bIntefaceCount  & 1 \\ \cline{2-3}
      & bFunctionClass  & 1 \\ \cline{2-3}
      & bFunctionSubClass & 1 \\ \cline{2-3}
      & bFunctionProtocol & 1 \\ \cline{2-3}
      & iFunction & 1 \\ \hline
\caption{List of descriptors and its fields}
\label{tab:list_descriptors}
\end{longtable}

\pagebreak
\begin{lstlisting}[caption={Example of device descriptor in C language},
                   label={lst:dsc_example},
                   language=c]
// device descriptor
uint8_t dsc_device[] = {
    0x12,                   // bLength
    0x01,                   // bDescriptorType
    WORD_TO_BYTES(0x0110),  // bcdUSB
    0x00,                   // bDeviceClass
    0x00,                   // bDeviceSubclass
    0x00,                   // bDeviceProtocol
    0x40,                   // bMaxPacketSize0
    WORD_TO_BYTES(0xD0D0),  // idVendor
    WORD_TO_BYTES(0xCAFE),  // idProduct
    WORD_TO_BYTES(0x0100),  // bcdVersion
    0x01,                   // iManufacture
    0x02,                   // iProduct
    0x00,                   // iSerialNumber
    0x01,                   // bNumConfigurations
};
\end{lstlisting}

% TODO:
\subsection*{Device Classes and Human Interface Device}
\label{hid}
There are plenty of devices that have something in common. All cameras capture a video, all flash disks transfer files, and so on. \textbf{Device classes} groups together devices that have similar functionalities. They serve as a guide for developers to design the device and programmers to write appropriate drivers. Operating systems include drivers for common classes which eliminates the need for the manufacturer to provide its own drivers.

There are two places where a developer can define the device's class code: in the \emph{device} or \emph{interface descriptors}. Some classes allow being only used in the former one, some in the latter one, and others in both. \autoref{tab:device_class} shows the list of base classes and their descriptor usage (which descriptor holds the information).

\begin{table}[ht]
    \centering
    \begin{tabular}{|c|c|p{0.39\linewidth}|} \hline
         \textbf{Base class code} & \textbf{Descriptor usage} & \textbf{Device class name} \\ \hline
         0x00 & Device      & Class information can be found in the interface descriptor \\ \hline
         0x01 & Interface   & Audio \\ \hline
         0x02 & Both        & Communications and Communications Device Class (CDC) \\ \hline
         0x03 & Interface   & Human Interface Device (HID) \\ \hline
         0x05 & Interface   & Physical \\ \hline
         0x06 & Interface   & Image \\ \hline
         0x07 & Interface   & Printer \\ \hline
         0x08 & Interface   & Mass Storage Device (MSD) \\ \hline
         0x09 & Device      & Hub \\ \hline
         0x0A & Interface   & CDC-Data \\ \hline
         0x0B & Interface   & Smart Card \\ \hline
         0x0D & Interface   & Content Security \\ \hline
         0x0E & Interface   & Video \\ \hline
         0x0F & Interface   & Personal Healthcare \\ \hline
         0x10 & Interface   & Audio/Video Devices \\ \hline
         0x11 & Device      & Billboard Device Class \\ \hline
         0x12 & Interface   & USB Type-C Bridge Class \\ \hline
         0x3C & Interface   & I3C Device Class \\ \hline
         0xDC & Both        & Diagnostic Device \\ \hline
         0xE0 & Interface   & Wireless Controller \\ \hline
         0xEF & Both        & Miscellaneous \\ \hline
         0xFE & Interface   & Application Specific \\ \hline
         0xFF & Both        & Vendor Specific \\ \hline
    \end{tabular}
    \caption{Device classes}
    \label{tab:device_class}
\end{table}

Each class specifies a list of conditions that a device has to meet in order to correctly communicate with the host, such as the number and types of required and optional endpoints, format of data that are transmitted between the host and device, status and control information relating to the device and its operations.

% \newpage
For example, we can analyze a \textbf{Human Interface Device} class. Human Interface Devices (or shortly HID) are devices that directly interact with people, such as mice, joystick, game controllers, steering wheels, and more. But it doesn't have to only be a physical object as a whole. HIDs let users interact with additional buttons, knobs, or slides. But just like any other classes, developers don't have to use HID only for devices that interact with people. They can use it for any other devices as long as their functional capabilities are within the limits of HID class
specification.

To communicate with the host, HID specifies a structure called \emph{reports}\footnote{More information about reports in following \autoref{reports}.}. HID has six class-specific requests that the host can send to the device in order to retrieve information or update the internal state of the device:
\begin{itemize}
    \item \verb|Get_Report| \--- Host uses this request to retrieve Input or Feature reports\footnote{More information about reports in \autoref{reports}} from the HID. To determine which report the host wants to get it sends a constant in the parameter of the request (Input=1, Feature=3). Every HID is \textbf{required} to implement this procedure/response to this request. 
    \item \verb|Set_Report| \--- Host uses this request to send the device Output or Feature reports. To determine which reports are incoming host passes as a parameter constant of the report (Output=2, Feature=3). Unless HID doesn't define \emph{Out Interrupt Endpoint descriptor} it doesn't have to implement a response to this request. 
    \item \verb|Get_Idle| \--- Used by the host to read the current idle rate of HID. The device is not required to implement a response to this request. 
    \item \verb|Set_Idle| \--- Used by the host to limit the reporting frequency of an IN interrupt endpoint. The device is not required to implement a response to this request unless it's a keyboard that uses the boot protocol.
    \item \verb|Get_Protocol| \--- Host uses this request to learn whether the device is currently using boot or request protocol. Only boot devices must support this request.
    \item \verb|Set_Protocol| \--- Host updates device's protocol. Only boot devices must support this request
\end{itemize}
Data are requested in either control or interrupt transfer. HID interface is required to support at most one IN interrupt endpoint for sending Input reports and one OUT interrupt endpoint or support for \emph{Set\_Report} request as listed above.

To declare a device as an HID, the developer needs to create a \emph{HID descriptor} that will be sent together with \emph{configuration descriptor} (as seen in an example of a composite device in \autoref{fig:hid_compose}). The class descriptor contains additional data needed by the host such as report data. The complete list of HID class descriptor fields is shown in \autoref{tab:hid_descriptor} with an example of a device that only uses reports as a data transfer medium in \autoref{lst:hid_example}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{obrazky-figures/hid_descriptor.png}
    \caption{Layout of descriptors for a composite device that consists of two HIDs.}
    \label{fig:hid_compose}
\end{figure}

\begin{lstlisting}[caption={Example of HID class descriptor in C language},
                   label={lst:hid_example},
                   language=c]
// HID class descriptor
uint8_t desc_hid[] = {
    0x09,                   // bLength
    0x21,                   // bDescriptorType   (HID class)
    WORD_TO_BYTES(0x0100),  // bcdHID
    0x00,                   // bCountryCode      (No localization)
    0x01,                   // bNumDescriptors   (Only reports)
    0x22,                   // bDescriptorType   (REPORT)
    0x40,                   // wDescriptorLength (64 bytes)
};
\end{lstlisting}
\begin{table}[ht]
    \centering
    \begin{tabular}{|l|l|p{0.6\linewidth}|} \hline
         \textbf{Field}     &  \thead{\textbf{Size} \\ \textbf{in bytes}} & \textbf{Description} \\ \hline
         bLength            & 1 & Descriptor size. \\ \hline
         bDescriptorType    & 1 & The constant for HID descriptor type: 0x21. \\ \hline
         bcdHID             & 2 & HID specification release number. \\ \hline
         bCountryCode       & 1 & Country identification number used for localized hardware. \\ \hline
         bNumDescriptors    & 1 & Number of subordinate report and physical descriptors. \\ \hline
         bDescriptorType    & 1 & Type of a class-specific descriptor that follows (0x22 for reports). \\ \hline
         wDescriptorLength  & 2 & The length of the descriptor selected above. \\ \hline
         bDescriptorType    & 1 & \emph{Optional}. Type of a class-specific descriptor that follows (0x23 for physical). \\ \hline
         wDescriptorLength  & 2 & \emph{Optional}. The length of the descriptor selected above. \\ \hline
    \end{tabular}
    \caption{HID class descriptor structure}
    \label{tab:hid_descriptor}
\end{table}

\newpage
\subsection*{Reports}
\label{reports}
As discussed in \autoref{hid}, reports are structures through which the host can send and receive data from the device. The format is very flexible meaning the device can send any type of data. The only limitation is that reports have a fixed size that is defined by a report descriptor.

\textbf{Report descriptor}, like other descriptors, is a structure that specifies the format of the report. It's a class-specific descriptor. If we look at \autoref{fig:hid_compose}, the compose device consists of two HID classes so we have to implement two separate report descriptors for each of them. 

The report content format is specified by a list of \emph{items}. Each item is divided into two parts: the first byte identifies the item and the second set of bytes contains data. An example of a keyboard report descriptor that defines an Input report can be found below in \autoref{lst:report_example}.
\begin{lstlisting}[caption={Example of report descriptor in C language},
                   label={lst:report_example},
                   language=c]
uint8_t report_desc[] = {
    0x05, 0x01, // Usage Page (Generic Desktop)
    0x09, 0x06, // Usage (Keyboard)
    0xA1, 0x01, // Collection (Application)
    0x05, 0x07, // Usage Page(Keyboard Usage Page)
    0x19, 0xE0, // Usage Minimum (0xE0)
    0x29, 0xE7, // Usage Maximum (0xE7)
    0x15, 0x00, // Logical Minimum (0x00)
    0x26, 0x01, // Logical Maximum (0x01)
    0x75, 0x01, // Report Size (0x01)
    0x95, 0x08, // Report Count (0x08)
    0x81, 0x02, // Input (Data, Variable, Absolute)
    0xC0,       // End Collection
};
\end{lstlisting}

We can divide items based on the scope of usage: Main, Global, or Local. Items in the main scope define or group data items within a report descriptor. Items in global scope identify and describe what kind of data to expect in the report, such as maximum and minimum values, size of the report, or the number of items in the report. And local items specify the qualities of the controls and data items in a report. 

Main scope defines five items: Input, Output, and Feature data items defining the content of a report. Collection and End Collection starts and ends the group. Input items apply to data that is sent from the device to the host. The host uses IN interrupt or Get\_Report request to request Input reports. Output items apply to data that the host sends to the device. They usually change the internal state of the device. For example, to vibrate a game controller during a fight in a game. The host uses OUT interrupt or Set\_Report request to send an Output report. Feature items apply to data that the host sends to the device. But it's not necessary and they can be used the other way around as well. Feature reports update the internal configuration settings of a device that affect the overall behavior of the device. For example, to turn on and off an LED on the keyboard. The host uses both Get\_Report and Set\_Report requests to send/retrieve Feature reports.

Global scope features twelve items which can be seen in \autoref{tab:global_items}. Usage Page specifies the function that the device performs. The HID Usage Table document lists the defined Usage Pages with their values and names. Usage Page are combined with Usage to identify the type of device. For example, Usage Page of \verb|0x01| and Usage of \verb|0x06| tell the host that the given report descriptor sends a keyboard report. Logical and Physical values define what values can report hold. Physical values are used with Units. Unit tag just specifies the unit of the data (time, mass, current. e. g.). It uses the SI (International System of Units) table. Report Size tells the host how many bits are used to encode the data into the report. Report Count tells how many fields will be sent.

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|p{0.7\linewidth}|} \hline
         \textbf{Global Item Type} & \textbf{Description} \\ \hline
         Usage Page & Specifies the data's usage or function \\ \hline
         Logical Minimum & Smallest value that an item will report \\ \hline
         Logical Maximum & Largest value that an item will report \\ \hline
         Physical Minimum & The logical minimum expressed in physical units \\ \hline
         Physical Maximum & The logical maximum expressed in physical units \\ \hline
         Unit Exponent & Base 10 exponent of units \\ \hline
         Unit & Unit values \\ \hline
         Report Size & Size of an item's field in bits \\ \hline
         Report ID & Prefix that identifies a report \\ \hline
         Report Count & The number of data fields for an item \\ \hline
         Push & Places a copy of the global item state table on the stack \\ \hline
         Pop & Replaces the item state table with the last structure pushed onto the stack \\ \hline
    \end{tabular}
    \caption{List of global items}
    \label{tab:global_items}
\end{table}

Local items specify the qualities of the controls and data items in a report. There are ten types of items: Usage, Usage Minimum/Maximum, Designator Index, Designator Minimum/maximum, String Index, String Minimum/Maximum, and Delimiter. 
\chapter{BadUSB}
\label{badusb}

BadUSB is a computer security attack that targets peripherals that use USB interfaces. Unlike the usual USB flash disk attacks where the drivers contain harmful files, BadUSB attacks are immune against antivirus programs since the actual code is stored in an inaccessible section of memory. The notion of the attack is to infect the firmware of the USB device. From keyboards and mice to smartphones, if the firmware is reprogrammable then the device is likely exploitable. In 2014 approximately 50 \% of USB microcontrollers  were pruned to this kind of infection.

\subsection*{First appearance}
BadUSB was first revealed during Black Hat conference in the USA. Three security researchers Karsten Nohl, Jakob Lell, and Sascha Krißler demonstrated a collection of proof-of-concept malicious software that highlights the security weakness of the USB\cite{BlackHat}. They spent months reverse-engineering the thumb drive the firmware that runs the basic communication of the device. Nohl and Lell say they've also tested their attack on the Android handset plugged into the PC. And once a BadUSB-infected device is connected to the computer, it could install corrupted software with the backdoor. 

Another type of attack was to hijack the internet traffic. The device changes the computer's DNS settings allowing the attack to redirect the traffic to any server he wants. It can also act as a man-in-the-middle, to spy the internet communication on the victim's computer.

The most horrific discovery was the idea that the infection can be spread amongst devices. Once and the USB device is connected to the infected computer, it can be silently reprogrammed with the user detecting anything.

One year later, in December 2015, a group of researchers from University of Florida, David Jing Tian, Adam Bates, and Kevin Butler, published a paper talking about a defense against BadUSB. They built a new layer on top of Linux USB Stack that enforces permissions based on user expectations of device functionality. The additional defense layer (called \emph{GoodUSB}) acts as a mediator and is activated during the enumeration process. GoodUSB restricts USB devices access to USB drivers based on a policy. According to the team, the defense mechanism slows down the enumeration process by only 5.2 \% (from 7 milliseconds to 9 milliseconds)\cite{goodusb}.

\subsection*{Rubber Ducky and Usage}
\label{rubber_ducky}
Rubber Ducky is one of the BadUSB devices that were demonstrated at the conference. They presented an ordinary USB flask drive that acts like a keyboard. Once connected to the computer the device started typing commands. That can be used to open a command prompt to download and install a malicious software, or (since Rubber Ducky lacks video feedback for the attacker) create a reverse shell. 

A reverse shell is a concept of connecting to the remote computer from the inside. For example, if I want to connect from the system A to B I can run a program named \textbf{ssh} (Secure Shell) on A. Reverse shell on the other hand run a shell on the system B that opens a shell on system A. What is the advantage of reverse shell? The fact that it bypasses firewall on system B. With reverse shell the attacker has access to the whole PC of a victim. 

In 2021, Hongyi Lu and his team at Southern University of Science and Technology published a paper regarding the upgraded version of the device. They implemented a BadUSB on top of a USB device with Type-C connector and named it \emph{BadUSB-C}. Type-C connector supports higher data transmit rate (10 Gbps) which is needed for video capturing. The team fitted a USB device with a Wifi module that lets them see the victim's screen content and control his device using HID emulator (as seen in \autoref{fig:badusbc_model} taken from the original work)\cite{badusbc}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{obrazky-figures/badusbc_attack.png}
    \caption{BadUSB-C's attack model}
    \label{fig:badusbc_model}
\end{figure}

But Rubber Ducky does not have to be seen only as a malicious device. Its ability to perform a script of commands/keystrokes makes it a perfect tool for repetitive tasks. For example, if a user benchmarks computers he can write a script that will configure the computer the same way every time. It's a powerful tool that can greatly help users with everyday tasks but also a dangerous device if used in the wrong way can cause a lot of damage. 

% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=200px]{obrazky-figures/89_usb-rubber-ducky-new.jpg}
%     \caption{Example of Rubber Ducky by Hak5}
%     \label{fig:rubber_ducky}
% \end{figure}
% TODO:

\chapter{Design and Architecture}
\label{designAndArchitecture}
In this section, we analyze the key features of this project. The goal here is to break down the whole problem into manageable parts, identify critical problems and come up with a solution. 

Since our device is based on Hak5's Rubber Ducky it must support its main functionality. The device will have the ability to execute a series of keystrokes that are stored within the firmware of the device. The software will provide an easy way to create, generate, and upload these payloads. Together with a keyboard, the device will also include Mass Storage where the user can store a shell basic script or executable file, which he/she can then run it on the host machine.
\todo{add use case diagram}

\section{Base device}
When designing a device capable of a BadUSB attack the first thing to consider is which device we should develop. We wanted a board that is publicly accessible, inexpensive, and easy to work with. After searching the current market we came across \emph{Raspberry Pi Pico} which matches our criteria. \textbf{Raspberry Pi Pico} is a small board with an RP2040 microcontroller chip designed by \emph{Raspberry Pi Foundation}. Its purpose is to encourage people to learn programming and build hardware projects without having to spend lots of money on the hardware itself. We chose a newer version of \emph{Raspberry Pi Pico} model \emph{W} as it also comes with a built-in \emph{CYW43439} wireless chip that supports both Wi-Fi and Bluetooth. That enables us to add a new use case to our project. And with a well-documented SDK\footnote{SDK stands for Software Development Kit} and great support for third-party libraries, this board is a perfect choice for us.

\section{Custom Rubber Ducky scripting language}
\label{customLanguage}
First, we need to think of a language which we will use to generate new payloads. The new language has to be intuitive and easy to write in. Since all the device can produce is keystrokes we need to find a to represent each key available on the keyboard. Luckily most (if not all) operating systems come with a keyboard driver preinstalled since it is a commonly used device. For this reason we don't need to write a driver for our keyboard emulator. \mbox{USB-IF} created a table with a list of supported keys and their IDs\footnote{The usage table can be found here: \url{https://usb.org/sites/default/files/hut1_4.pdf\#chapter.10}}. What that means is that we can build our language based on the IDs. That would be great for the machines as all they have to do is upload it directly to our Rubber Ducky device without any processing (apart from converting the ID values to bytes). But unfortunately, that doesn't meet our criteria for the language to be easy to write it. After all typing \verb|0c 11 17 18 0c 17 0c 19 08|\footnote{If you guessed \textbf{intuitive} then you are a master of ciphers.} feels more as to cipher a message than writing a payload.

Another possible way is to map each ID to a key name. That will make it a lot more human-readable. The only thing left to do is to figure out a way to tell the device to group a set of keystrokes together. Without this feature we would not be capable of producing an upper case \verb|f| since it takes two keys to be pressed at the same time: \textbf{Shift} and \textbf{f} keys.

What I come up with is a language inspired by a VIM key notation\footnote{VIM (which is an acronym to Vi IMproved) is a free open-source text editor. It is known among programmers as a text editor filled with keyboard shortcuts which makes coding and writing much faster and more efficient. Unfortunately, VIM has a steep learning curve making it not beginner-friendly. The official documentation for VIM key notation can be found here: \url{https://vimdoc.sourceforge.net/htmldoc/intro.html\#key-notation}}. The grammar of the language can be represented with a BNF notation seen in \autoref{fig:language_grammar_bnf}.

\begin{figure}[ht]
\label{fig:language_grammar_bnf}
\begin{verbatim}
<RD-SCRIPT>           ::= <COMMENT><RD-SCRIPT>   |
                          <DELAY><RD-SCRIPT>     |
                          <PRINTABLE><RD-SCRIPT> |
                          <SPECIAL-COMBINATION><RD-SCRIPT> |
                          <EOL>

<COMMENT>             ::= "#" everything after this is ignored

<DELAY>               ::= "<DELAY " <DELAY-VALUE> ">"

<DELAY-VALUE>         ::= positive whole number

<SPECIAL-COMBINATION> ::= "<" <HOLD-VALUE><MODIFIERS><PRINTABLES> ">" |
                          "<" <HOLD-VALUE><MODIFIERS><SPECIAL-KEY> ">"

<HOLD-VALUE>          ::= positive whole number "-" | ""

<MODIFIERS>           ::= <MODIFIER> "-" <MODIFIERS> | ""

<MODIFIER>            ::= modifier short alias

<SPECIAL-KEY>         ::= "\" <SPECIAL-OR-MACRO>

<SPECIAL-OR-MACRO>    ::= special key name | macro name

<PRINTABLES>          ::= <PRINTABLE><PRINTABLES> | ""

<PRINTABLE>           ::= ASCII printable character
\end{verbatim}
\caption{Language grammar in BNF notation} 
\end{figure}

There are two types of lexical tokens that the language accepts: \emph{printable keys} and \emph{special combinations}.

\textbf{Printable keys} are a group of keys that can produce an ASCII printable character. \todo{insert an ASCII table picture}
In total, there are 95 printable characters in the ASCII table ranging from 32, representing a \emph{space} character, to 126, representing a \emph{tilde} character. However, there are only 48 keys that directly produce a printable character. The second half of the keys also require a \emph{shift} modifier (the exception being a spacebar key which doesn't have a shift counterpart). So a string \verb|Hello World!| will produce the following list of keys seen in \autoref{fig:list_of_keys}:

\begin{figure}[ht]
\label{fig:list_of_keys}
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
shift+key_h, key_e, key_l, key_l, key_o, spacebar,
shift+key_w, key_o, key_r, key_l, key_d, shift+key_1  
\end{verbatim}
\end{varwidth}
\caption{\emph{Hello world!} converted to key presses.}
\end{figure}

One note here: due to the wide variety of different keyboard layouts the official key mapping is only compatible with the \emph{US layout}. What that means is that if the target's machine uses a different keyboard layout than the \emph{US layout} some keys or key combinations will produce a different string than expected. So for example with our machine's keyboard layout set to the Czech QWERTZ, the following set of keystrokes will produce output that the user probably didn't want:
\begin{figure}[ht]
\label{fig:layout_comparison}
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
Input:     page_123.cz
US layout: page_123.cz
CZ layout: page%+ěš.cy
\end{verbatim}
\end{varwidth}
\caption{Comparing outputs between cs-CZ and en-US layout given the same input string.}
\end{figure}

A \textbf{Special combination} gives the user more control over the key presses. It extends the functionality by adding features that cannot be executed using only \emph{printable keys}. The format of the \emph{special combination} looks as follows: 

\begin{figure}[ht]
\label{fig:format_special}
\centering
\begin{varwidth}{\linewidth}
\verb|"<" [special_combination_content] ">"|
\end{varwidth}
\caption{\emph{Special combination}'s content is wrapped in < and > symbols}
\end{figure}

There are four features that the user can define within the scope:
\begin{itemize}
    \item \emph{waiting time} between the keystrokes,
    \item pressing \emph{non-printable keys},
    \item pressing keys with \emph{modifiers} with an option to set a \emph{holding time},
    \item force multiple \emph{printable key} pressed simultaneously.
\end{itemize}

\textbf{Waiting time} or \textbf{delay} tells the device how long it has to wait before sending the next series of keystrokes to the host. This is very important, without it the payloads would fail most of the time since the device usually needs to wait until a GUI element loads or a file is downloaded. The format of a delay command looks as followed: \verb|<DELAY [delay_in_ms]>|. An example of the usage of the delay command can be seen in \autoref{fig:delay_example}.

\begin{figure}[ht]
\label{fig:delay_example}
\centering
\begin{varwidth}{\linewidth}
\verb|take <DELAY 5000> dave brubeck|
\end{varwidth}
\caption{In this example the USB device will type "take " string, wait 5 seconds, and finish by typing the string " dave brubeck".}
\end{figure}

\textbf{Non-printable keys} are, as the name suggests, keys that don't produce any printable characters \-- in other words all other keys. Of course, there are some notable exceptions. Even though \verb|Keypad_1| or \verb|Keypad_Asterisk| keys all produce a printable character (\verb|'1', '*'| respectively), they are not considered printable keys and to access them the user has to explicitly put them in the \emph{special combination} format in order to execute them. To differentiate non-printable keys from printable keys to former is written together with a \verb|\| prefix. Examples of non-printable keys can be seen in \autoref{fig:non_printable_example}. The parser doesn't distinguish between uppercase and lowercase letters (case-insensitive).

\begin{figure}[ht]
\label{fig:non_printable_example}
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
<\enter><\SPACEBAR><\BackSpace><\arrow_up><\f12><\num1><\volume_up>
\end{verbatim}
\end{varwidth}
\caption{Examples of non-printable key presses in custom Rubber Ducky script language.}
\end{figure}

Other additions to \emph{non-printable keys} are supports for \emph{modifier keys} and \emph{holding time}. \textbf{Modifier keys} are special keys that temporarily alter the action of a normal key (printable or non-printable key) when pressed together. There are in total 8 modifier keys:
\begin{itemize}
    \item left and right \verb|Alt|,
    \item left and right \verb|Control|,
    \item left and right \verb|Meta| (also known as Windows, Hyper, Super, or Command key depending on the operating system),
    \item left and right \verb|Shift|.
\end{itemize}
 We have already encountered a modifier key when discussing printable keys. When we press \verb|Shift| key together with \verb|Key_s| the \emph{shift} key changes the action of the \emph{s} key to output upper case \emph{S} instead of lowercase \emph{s} it would normally output. We can also associate modifier keys with keyboard shortcuts, the most famous one being \verb|alt+f4| to close an active window on Windows or \verb|ctrl+s| to save the content of a file. Modifier keys usually don't produce any action when pressed alone (Meta key notably being an exception) so they are handled differently when sending keystrokes to the host's machine. In the \emph{special combination} format modifier keys are placed before normal keys as seen in \autoref{fig:language_grammar_bnf}. Each modifier is identified by the location of the key followed by its starting letter \-- \verb|'la'| for \verb|LeftAlt|, \verb|'rs'| for \verb|RightShift|, and so on. If the user doesn't specify which one of the keys is meant, the left one will be chosen implicitly \-- \verb|'m'| will trigger \verb|LeftMeta|, \verb|'c'| will trigger \verb|LeftControl|, and so on. Each key is then separated with a \verb|-| separator.

\textbf{Holding time}, as the name suggests, defines how long a group of keys is meant to be pressed before releasing, measured in milliseconds. The hold delay value is expected to be at the start of the \emph{special combination}. This field is not required to be filled and the implicit value is set to 0. 

The last thing the \emph{special combination} scope supports is to force multiple \emph{printable keys} to be pressed at the same time. That is especially useful when the user wants to execute a keyboard shortcut that consists of two or more normal keys. As an example, we can use Visual Studio Code's\footnote{Visual Studio Code is a popular graphical text editor developed by Microsoft that supports extensions: \url{https://code.visualstudio.com/}} keyboard shortcut for closing all files in the editor: \verb|Ctrl+k Ctrl+w|. The language's equivalent of the given keystrokes is \verb|<c-kw>|. 

There are some letters that would not work in this format, \verb|<| and \verb|>| being the case. For that, I created a group of \emph{macro keys}. A \textbf{Macro key} is an alias to an existing key. It can be an alias to either the normal key or modifier key and is treated the same way as a \emph{non-printable key} \-- it starts with an escape backslash character followed by the name of the macro. So we can use \verb|<\gt>| and \verb|<\lt>| in to produce \verb|<| and \verb|>| respectively. 

The last feature of the language is the ability to write \emph{comments}. The comment grammar is inspired by scripting programming languages such as Bash or Python. It starts with \verb|#| symbol and the characters that follows this symbol are all ignored by the parser until the end of the line. There are no multi-line comments support. If the user wants to type a \verb|#| symbol he/she needs to put it into the \emph{special combination} scope. 

The following \autoref{lst:example_payload} shows an example payload written showcasing all the grammar syntax of the language.
\begin{lstlisting}[caption={Example payload in custom language.},
                   label={lst:example_payload}]
# ============================================================
# This is a single line comment

# let's open a terminal on Ubuntu using its keyboard shortcut
# and wait 500ms for it to open
<c-a-t><DELAY 500>

# ... now run a command
echo "hello world!"

# ... it doesn't work :( oh wait we must run it first!
<\enter>    # yay it outputs hello world!

# lets run some calculation in python now
python -c "a = 2<\enter><#> a = 4<\enter>print(a <\lt> 3)"<\enter>

# the commands from above should produce something like this
#     $ python -c "a = 2
#     # a = 4
#     print(a < 3)"

# now lets find the oldest command run on the machine!
# hopefully 10 seconds will be enough
<10000-\arrow_up><\enter>

# that is the end of our Linux terminal scripting 101 tutorial
# ============================================================
\end{lstlisting}

\section{Communication protocol}
Since our development board supports WiFi we made a decision to create a communication protocol and a network application based on it. Let our Rubber Ducky device be \emph{server} and our network application be \emph{client}. We need to define use cases for each side. This is a list of requests that we want the client to support:
\begin{itemize}
    \item Notify the device (server) that the client will send a new payload.
    \item Send to the device a new series of keystrokes.
    \item Remove the last sent set of keystrokes.
    \item Retrieve keystrokes from the device.
    \item Start the stored payload execution.
\end{itemize}

The server, on the other hand, will have only two types of responses: an \textbf{OK} response which signalizes that the request was successfully processed and an \textbf{ERR} response with an error message when something unexpected happened while processing the request.

What we came up with is a communication protocol on L7 application layer\footnote{More about Internet Network's ISO/OSI model here: \url{https://www.ietf.org/rfc/rfc1122.txt}} with a diagram shown in \autoref{fig:communication_protocol_packet_format}, \autoref{fig:communication_protocol_request}, and \autoref{fig:communication_protocol_response}. We wanted to simplify the packet's structure as much as possible. The packet header is 4 bytes long with the rest of the packet being filled with the packet's content (payload data). 

\begin{figure}[ht]
\label{fig:communication_protocol_packet_format}
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
                  Packet format
                  =============

      0           1           2           3      
+-----------+-----------+-----------+-----------+
|  OP CODE  | RESERVED  |    PAYLOAD LENGTH     |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                PAYLOAD DATA                   |
/                                               /
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\end{verbatim}
\end{varwidth}
\caption{Communication protocol's packet format used in the project.} 
\end{figure}

The first being of the header contains an \textbf{operational code}. It tells the server what kind of action we are requesting as well as informs the client about the operation's result. All operational codes are analyzed later in this section. The second byte in the header is \textbf{reserved} due to structure padding in C programming language. \todo{reference to a book}
Last two bytes in the header store \textbf{the size of the payload data}. Two bytes here will give us values ranging from 0 to 65 535 which should be plenty enough to carry the payload.

Next, we can analyze the request packet structure. Our project supports 9 \emph{operational codes} as shown in \autoref{fig:communication_protocol_request}. We can divide them into 4 groups:

\begin{enumerate}
    \item work with the USB device's (server's) inner read-write mode,
    \item update device payload,
    \item analyze the payload stored on the device,
    \item run the payload.
\end{enumerate}

\begin{figure}[ht]
\label{fig:communication_protocol_request}
\centering
\begin{varwidth}{\linewidth}
\begin{small}
\begin{verbatim}
                             Request
                             =======
Operation codes and their values:
+----+-------------+---------+--------------+--------------------------+
| op |   opcode    | payload |   expected   |       description        |
|    |    name     |  size   |     value    |                          |
+----+-------------+---------+--------------+--------------------------+
| 01 |     SET     |   01    |    00/01     |   Enable/disable device  |
|    |  EDITABLE   |         |              |      read-write mode     |
+----+-------------+---------+--------------+--------------------------+
| 02 |     GET     |   00    |      --      |      Check device's      |
|    |  EDITABLE   |         |              |  read-write mode status  |
+----+-------------+---------+--------------+--------------------------+
| 03 | CLEAR DATA  |   00    |      --      |      Clear device's      | *
|    |             |         |              |     current payload      |
+----+-------------+---------+--------------+--------------------------+
| 04 |  PUSH DATA  |   0d    | key sequence | Send a new key sequence  | *
+----+-------------+---------+--------------+--------------------------+
| 05 |  POP DATA   |   00    |      --      | Remove last key sequence | *
+----+-------------+---------+--------------+--------------------------+
| 06 |  GET DEBUG  |   00    |      --      | Retrieve a key sequence  |
|    |   CURSOR    |         |              |       at the debug       |
|    |             |         |              |     cursor's position    |
+----+-------------+---------+--------------+--------------------------+
| 07 | INC DEBUG   |   00    |      --      | Move debug cursor to the |
|    |   CURSOR    |         |              |    next key sequence     |
+----+-------------+---------+--------------+--------------------------+
| 08 | RESET DEBUG |   00    |      --      |   Reset debug cursor's   |
|    |   CURSOR    |         |              |         position         |
+----+-------------+---------+--------------+--------------------------+
| 09 |     RUN     |   00    |      --      | Tell the device to start | **
|    |  SEQUENCES  |         |              |  executing the payload   |
+----+-------------+---------+--------------+--------------------------+

*  - device must be set to read-write mode to run this command
** - device must be set to read-only mode to run this command
\end{verbatim}
\end{small}
\end{varwidth}
\caption{Set of request's operational codes, their payload, and description.} 
\end{figure}

The first two operational codes fall under the first group. Their purpose is to change or check whether the device is currently in read-write mode. There are other actions that depend on it. \verb|SET_EDITABLE| (0x01) sends a single-byte payload of 0x00, which will set device to \emph{read-only} mode, or 0x01, which will switch the device to \emph{read-write} mode. \verb|GET_EDITABLE| (0x02) retrieves the current mode present on the device.

The second group's purpose is to alter the payload stored on the device. It is required for the device to be in \emph{read-write} mode. Otherwise, the device will respond with an error message and the action will be ignored. \verb|CLEAR_DATA| (0x03) action removes the current payload from the device. \verb|PUSH_DATA| (0x04) uploads a new \emph{key sequence} to the device. The payload should contain the \emph{key sequence} data already reshaped to the desired format expected by the device\footnote{The expected format can be seen in \autoref{fig:key_sequence_format}. It is a 13 bytes long structure where \emph{waiting delay} occupies the first 4 bytes, followed by a 1 bitmap of \emph{modifiers} (\texttt{MDFR}), a reserved byte, 6 keyboards key IDs (see \autoref{customLanguage}), and a \texttt{LAST} byte, which indicates that this key sequence will be the last one in the series.}. \verb|POP_DATA| (0x05) removes the last inserted key sequence. Users can retrieve it from the server response payload.

\begin{figure}[ht]
\label{fig:key_sequence_format}
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
    0     1      2      3      4      5      6      7   
+------+------+------+------+------+------+------+------+
|            DELAY          | MDFR | RESV | KEY1 | KEY2 |
+------+------+------+------+------+------+------+------+
| KEY3 | KEY4 | KEY5 | KEY6 | LAST |
+------+------+------+------+------+
\end{verbatim}
\end{varwidth}
\caption{Key sequence format}
\end{figure}

The third group contains actions that serve as a debug tool for the user. The debug cursor always starts at the beginning of the series. A request with \verb|GET_DEBUG_CURSOR| (0x06) will retrieve a \emph{key sequence} which is currently under the cursor. To get the next key sequence the user needs to send a \verb|INC_DEBUG_CURSOR| (0x07) which moves the cursor to the next one (if it is available). Finally, the \verb|RESET_DEBUG_CURSOR| (0x08) request moves it back to the beginning.

The last operation on the list is a \verb|RUN_SEQUENCES| (0x09). As the name suggests, this request will start executing the payload on the device. The only requirement here is that the device must be in \emph{read-only} mode.

Now, we can analyze the last two operation codes which we can see in \autoref{fig:communication_protocol_response}. They are used by the server as a form of response to requests. \verb|OK| response is generated when the request is successfully generated. It can carry some data depending on the received request (for example \emph{key sequence} data as an answer to \verb|POP_DATA|, or device mode when received \verb|GET_EDITABLE|). The other type of response is \verb|ERR| which is generated when an error occurred during the request processing. This response will always carry the error message in its payload.

\begin{figure}[ht]
\label{fig:communication_protocol_response}
\centering
\begin{varwidth}{\linewidth}
\begin{verbatim}
                           Response
                           ========

+----+------+-------------+---------------------------+-----------+
| op | name | payload_len |       description         |  payload  |
+----+------+-------------+---------------------------+-----------+
| 0a | OK   |   varies    | Request was successfully  | data from |
|    |      |             |         processed         |   server  |
+----+------+-------------+---------------------------+-----------+
| 0b | ERR  |   varies    | Request was not correctly |   error   |
|    |      |             |         processed         |  message  |
+----+------+-------------+---------------------------+-----------+
\end{verbatim}
\end{varwidth}
\caption{Set of responses, their content, and description.}
\end{figure}

Let's end this section with a data flow diagram showcasing a possible communication between the \emph{server} (device) and the \emph{client} (user) shown below in \autoref{fig:dataflow_example}: 

\begin{figure}
    \centering
    \includegraphics{obrazky-figures/dataflow.pdf}
    \caption{Example of the communication between the client and the server. In this example, the user sends two key sequences to the device: \texttt{<\textbackslash{}enter><DELAY 500>}. We can also see the user making a mistake at the beginning of the communication by sending a \texttt{CLEAR\_DATA} request when the device is still in \emph{read-only mode}.}
    \label{fig:dataflow_example}
\end{figure}

\chapter{Implementation of Rubber Ducky-like device}
\label{implementation}
The purpose of this section is the familiarize the user with the actual structure of this project. The goal here is to show the reader how each part of the software is implemented. The design from \autoref{designAndArchitecture} will serve as our main source and all implemented parts of this project will be based on it. The first half of the chapter is dedicated to the Rubber Ducky software which I wrote using C programming language, and the second half deals with the Rubber Ducky script and client application for which I used Python.

\section{Used third-party libraries}
This project was developed using four open-source an SDK and libraries:
\begin{description}
    \item [pico-sdk] The Raspberry Pi Pico SDK (henceforth the SDK) provides the headers, libraries and build system necessary to write programs for the RP2040-based devices such as the Raspberry Pi Pico in C, C++, or assembly language.\footnote{\url{https://github.com/raspberrypi/pico-sdk}}
    \item [cyw43-driver] An open-source library which implements a driver for CYW43xx WiFi/BT SoC.\footnote{\url{https://github.com/georgerobotics/cyw43-driver}}
    \item [TinyUSB] TinyUSB is an open-source cross-platform USB Host/Device stack for embedded systems, designed to be memory-safe with no dynamic allocation and thread-safe with all interrupt events deferred and then handled in the non-ISR task function.\footnote{\url{https://github.com/hathach/tinyusb}}
    \item [lwIP] lwIP library is a small independent implementation of the TCP/IP protocol suite. The focus of the lwIP TCP/IP implementation is to reduce the RAM usage while still having a full-scale TCP.\footnote{\url{https://github.com/lwip-tcpip/lwip}}
\end{description}

\section{Rubber Ducky device}
The Rubber Ducky device implementation can be divided into two parts. In the first part, we need to configure the USB device to make it ready for the enumeration process. TinyUSB library requires \verb|tusb_config.h| header file, which defines configuration macros, such as \verb|CFG_TUD_ENABLED| to set the device as a "device" and not as a "host", or \verb|CFG_TUD_HID| which defines how many HID configurations will the device have, and more. Part of the configuration was moved to \verb|config.h| header file. This file contains macros that the user can freely edit. \verb|config.h| is then imported to \verb|tusb_config.h|.


\section{TCP Server}
\section{Script parser}
\section{Client application}
\chapter{Rubber Ducky test}
\label{practicalTest}
% TODO:

\chapter{Attack payloads}
\label{attackPayloads}
This section 
% TODO:

\chapter{Defense and Testing}
\label{defense}
% TODO:

\chapter{Conclusion}
\label{conclusion}
% TODO: